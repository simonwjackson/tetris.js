{"version":3,"sources":["src\\utils.js","src\\core.js","src\\tetris.js"],"names":["createMatrix","w","h","matrix","push","Array","fill","rand","min","max","Math","ceil","floor","random","createPiece","type","hasCollision","arena","player","m","o","pos","some","yVal","yIdx","xVal","xIdx","y","x","module","hot","dispose","location","reload","scale","border","colors","canvas","document","getElementById","context","getContext","dropCounter","dropInterval","lastDraw","arenaSweep","rowCount","length","outer","row","splice","unshift","score","merge","map","value","playerDrop","playerReset","updateScore","innerHTML","draw","fillStyle","fillRect","width","height","update","time","deltaTimeDraw","bind","drawMatrix","offset","drawSquare","color","squareSize","startX","startY","strokeStyle","lineWidth","strokeRect","move","direction","rotate","r","reverse","playerRotate","dir","pieces","letter","bindControls","addEventListener","key","init"],"mappings":"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","file":"tetris.ff202f0f.map","sourceRoot":"..","sourcesContent":["// Refactor as reducer\r\nexport const createMatrix = (w, h) => { \r\n  const matrix = []\r\n  while (h--) {\r\n    matrix.push(new Array(w).fill(0))\r\n  }\r\n  return matrix \r\n}\r\n\r\nexport const rand = (min, max) => {\r\n  min = Math.ceil(min)\r\n  max = Math.floor(max)\r\n\r\n  return Math.floor(Math.random() * (max - min + 1)) + min //The maximum is inclusive and the minimum is inclusive\r\n}\r\n","export const createPiece = type => {\r\n  switch (type) {\r\n    case \"O\":\r\n      return [\r\n        [1, 1],\r\n        [1, 1],\r\n      ]\r\n      break\r\n\r\n    case \"Z\":\r\n      return [\r\n        [2, 2, 0],\r\n        [0, 2, 2],\r\n        [0, 0, 0]\r\n      ]\r\n      break\r\n\r\n    case \"S\":\r\n      return [\r\n        [0, 3, 3],\r\n        [3, 3, 0],\r\n        [0, 0, 0]\r\n      ]\r\n      break\r\n\r\n    case \"J\":\r\n      return [\r\n        [0, 1, 0],\r\n        [0, 1, 0],\r\n        [1, 1, 0]\r\n      ]\r\n      break \r\n\r\n    case \"L\":\r\n      return [\r\n        [0, 2, 0],\r\n        [0, 2, 0],\r\n        [0, 2, 2]\r\n      ]\r\n      break\r\n\r\n    case \"I\":\r\n      return [\r\n        [0, 2, 0, 0],\r\n        [0, 2, 0, 0],\r\n        [0, 2, 0, 0],\r\n        [0, 2, 0, 0]\r\n      ]\r\n      break\r\n\r\n    case \"T\": \r\n      return [\r\n        [0, 0, 0],\r\n        [3, 3, 3],\r\n        [0, 3, 0]\r\n      ]\r\n      break\r\n  }\r\n}\r\n\r\nexport const hasCollision = (arena, player) => {\r\n  const m = player.matrix\r\n  const o = player.pos\r\n\r\n  return m.some((yVal, yIdx) => (\r\n    yVal.some((xVal, xIdx) => {\r\n      if (m[yIdx][xIdx] !== 0 &&\r\n        (arena[yIdx + o.y] &&\r\n          arena[yIdx + o.y][xIdx + o.x]) !== 0) {\r\n        return true\r\n      } \r\n\r\n      return false\r\n    })\r\n  ))\r\n}","/* HOTFIX: Parcel full reload for canvas */\r\nif (module.hot) {\r\n  module.hot.dispose(() => {\r\n    window.location.reload();\r\n    throw 'whatever'\r\n  })\r\n}\r\n\r\nimport './main.css'\r\nimport { createMatrix, rand } from './utils'\r\nimport { hasCollision, createPiece } from './core'\r\n\r\nconst scale = 20\r\nconst border = scale * .1\r\nconst colors = [\r\n  null,\r\n  'hsl(203, 100%, 67%)',\r\n  'hsl(226, 96%, 56%)',\r\n  'hsl(0, 0%, 99%)'\r\n]\r\nconst canvas = document.getElementById('tetris')\r\nconst context = canvas.getContext('2d')\r\nconst arena = createMatrix(10, 20)\r\nconst player = {\r\n  pos: {\r\n    x: 0,\r\n    y: 0\r\n  },\r\n  matrix: null,\r\n  score: 0\r\n}\r\n\r\nlet dropCounter = 0\r\nlet dropInterval = 1000\r\nlet lastDraw = 0\r\n\r\n// context.scale(10, 10)\r\n\r\nconst arenaSweep = () => {\r\n  let rowCount = 1\r\n  outer: for (let y = arena.length - 1; y > 0; --y) {\r\n    for (let x = 0; x < arena[y].length; ++x) {\r\n      if (arena[y][x] === 0) {\r\n        continue outer;\r\n      }\r\n    }\r\n\r\n    const row = arena.splice(y, 1)[0].fill(0)\r\n    arena.unshift(row)\r\n    ++y\r\n\r\n    player.score += rowCount * 10\r\n    rowCount *= 2\r\n  }\r\n}\r\n\r\nconst merge = (arena, player) => {\r\n  player.matrix.map((row, y) => {\r\n    row.map((value, x) => {\r\n      if (value !== 0) arena[y + player.pos.y][x + player.pos.x] = value\r\n    })\r\n  })\r\n}\r\n\r\nconst playerDrop = () => {\r\n  player.pos.y++\r\n\r\n  if (hasCollision(arena, player)) {\r\n    player.pos.y--\r\n    merge(arena, player)\r\n    playerReset()\r\n    arenaSweep()\r\n    updateScore(player.score)\r\n    player.pos.y = 0\r\n  }\r\n\r\n  dropCounter = 0\r\n}\r\n\r\nconst updateScore = score => {\r\n  document.getElementById('score').innerHTML = score\r\n}\r\n\r\nconst draw = player => {\r\n  context.fillStyle = '#000'\r\n  context.fillRect(0, 0, canvas.width, canvas.height)\r\n\r\n  drawMatrix(arena, { x: 0, y: 0 }) // Existing blocks\r\n  drawMatrix(player.matrix, player.pos) // Current block\r\n}\r\n\r\nconst update = (player, time = 0) => {\r\n  const deltaTimeDraw = time - lastDraw\r\n  lastDraw = time\r\n\r\n  dropCounter += deltaTimeDraw\r\n  if (dropCounter > dropInterval) playerDrop()\r\n\r\n  draw(player)\r\n  requestAnimationFrame(update.bind(null, player))\r\n}\r\n\r\nconst drawMatrix = (matrix, offset) => {\r\n  matrix.map((row, y) => {\r\n    row.map((value, x) => {\r\n      if (value !== 0) {\r\n        drawSquare(colors[value], x, y, offset, scale, border)\r\n      }\r\n    })\r\n  })\r\n}\r\n\r\nconst drawSquare = (color, x, y, offset, scale, border) => {\r\n  const squareSize = scale - border\r\n  const startX = (x + offset.x) * scale\r\n  const startY = (y + offset.y) * scale\r\n  context.fillStyle = color\r\n  context.fillRect(startX, startY, squareSize, squareSize)\r\n  context.fillStyle = 'white'\r\n  context.fillRect(startX, startY, 2, 2)\r\n  context.fillRect(startX + 2, startY + 2, 2, 4)\r\n  context.fillRect(startX + 2, startY + 2, 4, 2)\r\n\r\n  if (color === 'hsl(0, 0%, 99%)') { \r\n    context.strokeStyle = colors[1];\r\n    context.lineWidth = 3;\r\n    context.strokeRect(startX + 1, startY + 1, squareSize - 2, squareSize - 2);\r\n  }\r\n}\r\n\r\nconst move = direction => {\r\n  player.pos.x += direction\r\n  if (hasCollision(arena, player))\r\n    player.pos.x -= direction\r\n}\r\n\r\nconst rotate = (matrix, direction) => {\r\n  for (let yIdx = 0; yIdx < matrix.length; ++yIdx) {\r\n    for (let xIdx = 0; xIdx < yIdx; ++xIdx) {\r\n      [\r\n        matrix[xIdx][yIdx],\r\n        matrix[yIdx][xIdx]\r\n      ] = [\r\n          matrix[yIdx][xIdx],\r\n          matrix[xIdx][yIdx]\r\n        ]\r\n    }\r\n  }\r\n\r\n  if (direction > 0) matrix.map(r => r.reverse())\r\n  else matrix.reverse()\r\n}\r\n\r\nconst playerRotate = direction => {\r\n  const pos = player.pos.x\r\n  let offset = 1\r\n  rotate(player.matrix, direction)\r\n\r\n  while (hasCollision(arena, player)) {\r\n    player.pos.x += offset\r\n    offset = -(offset + (offset > 0 ? 1 : -1))\r\n    if (offset > player.matrix[0].length) {\r\n      rotate(player.matrix, -dir)\r\n      player.pos.x = pos\r\n      return\r\n    }\r\n  }\r\n  // const { x: pos } = player.pos\r\n  // let offset = 1\r\n  // rotate(player.matrix, direction) \r\n  // console.table(hasCollision(arena, matrix))\r\n  // while (hasCollision(arena, matrix)) {\r\n  //   player.pos.x += offset\r\n  //   offset = -(offset + (offset > 0 ? 1 : -1))\r\n  //   if (offset > player.matrix[0].length) {\r\n  //     rotate(player.matrix, -dir)\r\n  //     player.pos.x = pos\r\n  //     return\r\n  //   }\r\n  // }\r\n}\r\n\r\nconst playerReset = () => {\r\n  const pieces = 'ILJOTSZ'\r\n  const num = rand(0, pieces.length - 1)\r\n  const letter = pieces[num]\r\n\r\n  player.matrix = createPiece(letter)\r\n  player.pos.y = 0\r\n  player.pos.x = (arena[0].length / 2 | 0) -\r\n    (player.matrix[0].length / 2 | 0)\r\n\r\n  // Clear Screen\r\n  if (hasCollision(arena, player)) {\r\n    arena.map(row => row.fill(0))\r\n    player.score = 0\r\n    updateScore()\r\n  }\r\n}\r\n\r\nconst bindControls = player => {\r\n  document.addEventListener('keydown', ({ key }) => {\r\n    switch (key) {\r\n      case \"ArrowLeft\":\r\n        move(-1)\r\n        break\r\n      case \"ArrowRight\":\r\n        move(1)\r\n        break\r\n      case \"ArrowDown\":\r\n        playerDrop()\r\n        break\r\n      case \"q\":\r\n        playerRotate(1)\r\n        break\r\n      case \"w\":\r\n        playerRotate(-1)\r\n        break\r\n    }\r\n  })\r\n}\r\n\r\nconst init = () => {\r\n  bindControls(player)\r\n  playerReset()\r\n  updateScore(player.score)\r\n}\r\n\r\ninit()\r\nupdate(player)\r\n"]}